//! This is a example program that plays a simple, 3-channel tune via opl3-rs and the `rodio` audio
//! library.
//!
//! Original code by Maarten Janssen (maarten@cheerful.nl) 2016-04-13
//! Most recent version of the library can be found at my GitHub: https://github.com/DhrBaksteen/ArduinoOPL2
//! Hacked for a OPL2LPT test program by pdewacht@gmail.com.
//! Rewritten in Rust by Daniel Balsom for opl3-rs
//!
use std::io::Write;
use std::sync::{Arc, Mutex};

use chrono::Duration;
use crossbeam_channel::unbounded;
use rodio::cpal::traits::HostTrait;
use rodio::DeviceTrait;
use timer::Timer;

use crate::music_player::CallbackMessage;
use crate::music_player::MusicPlayer;
use crate::opl::*;
use crate::opl_instruments::*;

mod music_player;
mod opl;
mod opl_instruments;

const TIMER_FREQ: i64 = 100; // We will set a timer callback at 100Hz

fn main() {
    let audio_device = rodio::cpal::default_host()
        .default_output_device()
        .expect("No audio device found.");

    let device_name = audio_device.name().expect("Couldn't get adapter name.");

    let config = audio_device
        .default_output_config()
        .expect("Couldn't get device configuration.");

    let sample_rate = config.sample_rate().0;
    let channels = config.channels() as usize;
    let sample_format = config.sample_format().to_string();

    let (_stream, stream_handle) =
        rodio::OutputStream::try_from_device(&audio_device).expect("Couldn't open rodio stream.");

    println!(
        "Opened audio device: {}, sample rate: {}, channels: {}, format: {:?}",
        device_name, sample_rate, channels, sample_format
    );

    play_music(sample_rate, stream_handle);
    //play_note(sample_rate, stream_handle);
}

#[allow(dead_code)]
fn play_note(sample_rate: u32, stream_handle: rodio::OutputStreamHandle) {
    // Create a stereo buffer one second long. (Length = Sample rate * 2 channels)
    let mut samples = vec![0; 2 * sample_rate as usize];

    // Create the music player. We don't use this channel in this example.
    let (s, _r) = unbounded();
    let mut player = MusicPlayer::new(sample_rate, s);

    // Start the player and play a single note, leaving it sustained.
    player.setup();
    player.play_test_note(&OPL_INSTRUMENT_ORGAN1, NOTE_C, 2);

    // Generate 1 second of samples.
    player.generate_direct(&mut samples);

    // Write buf to file
    let mut file = std::fs::File::create("test.raw").unwrap();
    for sample in &samples {
        file.write(&sample.to_le_bytes()).unwrap();
    }

    // Convert samples to f32.
    let channel_samples: Vec<f32> = samples
        .iter_mut()
        .map(|c| *c as f32 / i16::MAX as f32)
        .collect();

    for sample in &channel_samples[1000..2000] {
        println!("Sample: {}", sample);
    }

    println!("Got {} samples", channel_samples.len());
    let samples_buf = rodio::buffer::SamplesBuffer::new(2, sample_rate, channel_samples);

    stream_handle
        .play_raw(samples_buf)
        .expect("Couldn't play sound");

    std::thread::sleep(std::time::Duration::from_secs(1));
}

fn play_music(sample_rate: u32, stream_handle: rodio::OutputStreamHandle) {
    // Create a channel to receive the audio samples as they are generated by the timer callback.
    let (s, r) = unbounded();

    // Create the music player.
    let mut player = MusicPlayer::new(sample_rate, s);
    // Start the player
    player.setup();
    // Wrap the player in an Arc<Mutex<>> so we can share it with the timer callback.
    let player_arc = Arc::new(Mutex::new(player));

    let sink = rodio::Sink::try_new(&stream_handle).expect("Couldn't create sink!");

    let freq_duration = Duration::milliseconds(1000 / TIMER_FREQ);
    let timer = Timer::new();

    // Set up the timer callback. The result of schedule_repeating is saved to a guard variable to
    // determine the callback's lifetime.
    let _guard = {
        timer.schedule_repeating(freq_duration, move || {
            let mut player_lock = player_arc.lock().unwrap_or_else(|e| {
                eprintln!("Error locking player: {:?}", e);
                // exit to os
                std::process::exit(1);
            });
            player_lock.timer_callback();
        })
    };

    // Start playing the sink.
    sink.play();

    // Loop and receive messages/samples from the callback.
    let mut end_playback = false;
    while !end_playback {
        let message = r.recv().unwrap_or_else(|e| {
            eprintln!("Error receiving channel message: {:?}", e);
            // exit to os
            CallbackMessage::Error
        });
        match message {
            CallbackMessage::Error | CallbackMessage::EndPlayback => {
                end_playback = true;
            }
            CallbackMessage::HaveSamples(samples) => {
                let channel_samples: Vec<f32> = samples
                    .iter()
                    .map(|c| *c as f32 / i16::MAX as f32)
                    .collect();

                let buf = rodio::buffer::SamplesBuffer::new(2, sample_rate, channel_samples);
                sink.append(buf);
            }
        }
    }
}
