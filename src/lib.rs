// #opl3-rs
// A simple wrapper around the OPL3 chip library.
// Bindings generated by Daniel Balsom.
//
// Nuked OPL3 Copyright (C) 2013-2020 Nuke.YKT
#![warn(missing_docs)]
#![doc = include_str!("./docs.md")]

/*
* Nuked OPL3 is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation, either version 2.1
* of the License, or (at your option) any later version.
*
* Nuked OPL3 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with Nuked OPL3. If not, see <https://www.gnu.org/licenses/>.

*  Nuked OPL3 emulator.
*  Thanks:
*      MAME Development Team(Jarek Burczynski, Tatsuyuki Satoh):
*          Feedback and Rhythm part calculation information.
*      forums.submarine.org.uk(carbon14, opl3):
*          Tremolo and phase generator calculation information.
*      OPLx decapsulated(Matthew Gambrell, Olli Niemitalo):
*          OPL2 ROMs.
*      siliconpr0n.org(John McMaster, digshadow):
*          YMF262 and VRC VII decaps and die shots.
*
* version: 1.8
*/

use std::sync::{Arc, Mutex};

unsafe impl Send for Opl3Chip {}

mod bindings;

/// The `Opl3DeviceStats` struct contains statistics about the OPL3 device.
/// It can be retrieved via the `get_stats` function on `Opl3Device`.
#[derive(Copy, Clone, Default)]
pub struct Opl3DeviceStats {
    /// The number of writes to the OPL3 data register since reset.
    pub data_writes: usize,
    /// The number of writes to the OPL3 address register since reset.
    pub addr_writes: usize,
    /// The number of reads from the OPL3 status register since reset.
    pub status_reads: usize,
    /// The number of samples generated since reset. A stereo pair (left and right) is considered
    /// one sample.
    pub samples_generated: usize,
}

/// The `Opl3Device` struct provides convenience functions for fully implementing an OPL3 device on
/// top of Nuked-OPL3.
/// By keeping a copy of all registers written, we can implement a read_register function.
pub struct Opl3Device {
    addr_reg: u8,
    status_reg: u8,
    sample_rate: u32,
    registers: [u8; 256],
    stats: Opl3DeviceStats,
    inner_chip: Arc<Mutex<Opl3Chip>>,
}

impl Opl3Device {
    /// Create a new OPL3 device instance.
    /// `Opl3Device` is a convenience wrapper around the Nuked-OPL3's direct wrapper, `Opl3Chip`.
    /// It provides the rest of an OPL3 implementation on top of the chip, including register
    /// tracking and a read_register function.
    pub fn new(sample_rate: u32) -> Self {
        Opl3Device {
            addr_reg: 0,
            status_reg: 0,
            sample_rate,
            registers: [0; 256],
            stats: Opl3DeviceStats::default(),
            inner_chip: Arc::new(Mutex::new(Opl3Chip::new(sample_rate))),
        }
    }

    /// Retrieve the statistics for the OPL3 device in the form of an `Opl3DeviceStats` struct.
    pub fn stats(&self) -> Opl3DeviceStats {
        self.stats
    }

    /// Write a byte to the OPL3 device's Address register.
    /// This function, along with write_data, is likely the primary interface for an emulator
    /// implementing an OPL device.
    ///
    /// # Arguments
    ///
    /// * `addr` - The register address to write to the OPL3 device, in the range 0..=255.
    pub fn write_address(&mut self, addr: u8) {
        if (addr as u16) < 256 {
            self.status_reg = addr;
        }
    }

    /// Write a byte to the OPL3 device's Data register.
    /// This function, along with write_address, is likely the primary interface function for an
    /// emulator implementing an OPL device.
    ///
    /// The actual internal register to be written should be set by writing to the OPL3 address
    /// register via `write_address` before calling `write_data`.
    ///
    /// # Arguments
    ///
    /// * `data`     - The byte of data to write to the OPL3 device.
    /// * `buffered` - Whether to write the data in buffered mode. In buffered mode, Nuked-OPL3
    ///                will store the write in a buffer and execute it after any necessary delay.
    ///                This is useful for controlling the library manually, but if you are
    ///                implementing an emulator the software controlling the OPL3 module will
    ///                likely write registers with appropriate timings.
    pub fn write_data(&mut self, data: u8, buffered: bool) {
        self.write_register(self.addr_reg as u16, data, buffered);
    }

    /// Return the value of the given chip register from internal state.
    /// The OPL3 registers are not natively readable. `Opl3Device` keeps a copy of all registers
    /// written so that they can be queried. This internal state will become desynchronized if
    /// registers are written directly to the OPL3 chip.
    ///
    /// # Arguments
    ///
    /// * `reg` - The internal register index to read.
    pub fn read_register(&self, reg: u16) -> u8 {
        if reg < 256 {
            self.registers[reg as usize]
        } else {
            0
        }
    }

    /// Write to the specified register directly. This will update the internal state of the
    /// Opl3Device so that the register value can later be read.
    ///
    /// # Arguments
    ///
    /// * `reg` - The internal register index to write.
    /// * `value` - The value to write to the register.
    /// * `buffered` - Whether to write the data in buffered mode. In buffered mode, Nuked-OPL3
    ///                will store the write in a buffer and execute it after any necessary delay.
    ///                This is useful for controlling the library manually, but if you are
    ///                implementing an emulator the software controlling the OPL3 module will
    ///                likely write registers with appropriate timings.
    pub fn write_register(&mut self, reg: u16, value: u8, buffered: bool) {
        if reg < 256 {
            self.stats.data_writes = self.stats.data_writes.saturating_add(1);

            //println!("{:03X}:{:02X} ({})", reg, value, self.stats.data_writes);

            self.registers[reg as usize] = value;
            if buffered {
                self.inner_chip
                    .lock()
                    .unwrap()
                    .write_register_buffered(reg, value);
            } else {
                self.inner_chip.lock().unwrap().write_register(reg, value);
            }
        }
    }

    /// Reset the Opl3Device.
    /// Reset the state of the OPL3 device, including the internal registers and the internal
    /// Nuked-OPL3 instance.
    ///
    /// # Arguments
    ///
    /// * `sample_rate` - An option that either contains the new sample rate to reinitialize with
    ///                   or None to keep the current sample rate.
    pub fn reset(&mut self, sample_rate: Option<u32>) {
        let new_sample_rate = sample_rate.unwrap_or(self.sample_rate);
        self.inner_chip.lock().unwrap().reset(new_sample_rate);
        for reg in 0..256 {
            self.write_register(reg, 0, true);
        }
        self.stats = Opl3DeviceStats::default();
    }

    /// Generate a 2 channel audio sample in interleaved i16 format.
    ///
    /// # Arguments
    ///
    /// * `sample` - A mutable reference to a two-element slice that will receive the audio sample.
    ///              The first element will contain the left channel sample, and the second element
    ///              will contain the right channel sample.
    pub fn generate(&mut self, sample: &mut [i16]) {
        self.inner_chip.lock().unwrap().generate(sample);
    }

    /// Generate a stream of 2 channel, interleaved audio samples in i16 format.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A mutable reference to a buffer slice that will be filled with stereo, i
    ///              interleaved audio samples.
    pub fn generate_samples(&mut self, buffer: &mut [i16]) {
        self.inner_chip.lock().unwrap().generate_stream(buffer);
    }
}

/// The `Opl3Chip` struct provides a safe interface for interacting with the Nuked-OPL3 library.
pub struct Opl3Chip {
    chip: bindings::Opl3Chip,
}

impl Opl3Chip {
    /// Creates a new OPL3 chip instance.
    ///
    /// # Arguments
    ///
    /// * `sample_rate` - The sample rate to initialize the OPL3 chip with.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// ```
    pub fn new(sample_rate: u32) -> Self {
        unsafe {
            let mut chip: bindings::Opl3Chip = std::mem::zeroed();
            bindings::Opl3Reset(&mut chip, sample_rate);
            Opl3Chip { chip }
        }
    }

    /// Reinitialize the OPL3 chip instance.
    ///
    /// # Arguments
    ///
    /// * `sample_rate` - The sample rate to initialize the OPL3 chip with.
    ///                   I have not tested the effects of reinitializing the chip with a different
    ///                   sample rate than the one initially used.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// chip.reset(44100);
    /// ```
    pub fn reset(&mut self, sample_rate: u32) {
        unsafe {
            bindings::Opl3Reset(&mut self.chip, sample_rate);
        }
    }

    /// Generate audio samples.
    ///
    /// Internally, this calls Opl3Generate4Ch and returns samples for the first 2 channels..
    /// Therefore, the buffer provided must be 4 samples long.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A mutable reference to a buffer that will receive the audio samples.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// let mut buffer = [0i16; 4];
    /// chip.generate(&mut buffer);
    /// ```
    pub fn generate(&mut self, buffer: &mut [i16]) {
        if buffer.len() < 4 {
            panic!("Buffer must be at least 4 samples long.");
        }
        unsafe {
            bindings::Opl3Generate(&mut self.chip, buffer.as_mut_ptr());
        }
    }

    /// Generates resampled audio samples.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A mutable reference to a buffer that will be filled with resampled audio samples.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// let mut buffer = [0i16; 4];
    /// chip.generate_resampled(&mut buffer);
    /// ```
    pub fn generate_resampled(&mut self, buffer: &mut [i16]) {
        if buffer.len() < 4 {
            panic!("Buffer must be at least 4 samples long.");
        }
        unsafe {
            bindings::Opl3GenerateResampled(&mut self.chip, buffer.as_mut_ptr());
        }
    }

    /// Writes a value to an OPL register.
    ///
    /// # Arguments
    ///
    /// * `reg` - The register to write to.
    /// * `value` - The value to write to the register.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// chip.write_register(0x20, 0x01);
    /// ```
    pub fn write_register(&mut self, reg: u16, value: u8) {
        unsafe {
            bindings::Opl3WriteReg(&mut self.chip, reg, value);
        }
    }

    /// Write a value to an OPL register, in buffered mode.
    ///
    /// The OPL3 normally requires a delay between register writes. This function
    /// will queue the write operation and execute it after any necessary delay.
    ///
    /// # Arguments
    ///
    /// * `reg` - The register to write to.
    /// * `value` - The value to write to the register.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// chip.write_register_buffered(0x20, 0x01);
    /// ```
    pub fn write_register_buffered(&mut self, reg: u16, value: u8) {
        unsafe {
            bindings::Opl3WriteRegBuffered(&mut self.chip, reg, value);
        }
    }

    /// Generates a stream of resampled audio samples.
    ///
    /// The number of samples generated is determined by the size of the buffer.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A mutable reference to a buffer that will be filled with resampled audio samples.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// let mut buffer = [0i16; 4];
    /// chip.generate_stream(&mut buffer);
    /// ```
    pub fn generate_stream(&mut self, buffer: &mut [i16]) {
        unsafe {
            bindings::Opl3GenerateStream(
                &mut self.chip,
                buffer.as_mut_ptr(),
                buffer.len() as u32 / 2,
            );
        }
    }

    /// Generate 4 channel audio samples.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A mutable reference to a buffer that will receive the audio samples.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// let mut buffer = [0i16; 4];
    /// chip.generate_4ch(&mut buffer);
    /// ```
    pub fn generate_4ch(&mut self, buffer: &mut [i16]) {
        if buffer.len() < 4 {
            panic!("Buffer must be at least 4 samples long.");
        }
        unsafe {
            bindings::Opl3Generate4Ch(&mut self.chip, buffer.as_mut_ptr());
        }
    }

    /// Generate 4 channel resampled audio samples.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A mutable reference to a buffer that will receive the resampled audio samples.
    ///
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// let mut buffer = [0i16; 4];
    /// chip.generate_4ch_resampled(&mut buffer);
    /// ```
    pub fn generate_4ch_resampled(&mut self, buffer: &mut [i16]) {
        if buffer.len() < 4 {
            panic!("Buffer must be at least 4 samples long.");
        }
        unsafe {
            bindings::Opl3Generate4ChResampled(&mut self.chip, buffer.as_mut_ptr());
        }
    }

    /// Generates a stream of 4-channel audio samples, resampled to the configured sample rate.
    /// The OPL3 was capable of 4-channel output, although this feature was not widely used. Most
    /// cards simply didn't provide 4-channel outputs, although there now exist modern reproduction
    /// cards that do.
    ///
    /// The number of samples is determined by the size of the input buffers.
    ///
    /// # Arguments
    ///
    /// * `buffer1` - A mutable reference to a slice that will be filled with the first stereo
    ///               audio samples, interleaved between left and right channels.
    /// * `buffer2` - A mutable reference to a slice that will be filled with audio samples for the
    ///               channels 2 and 3.
    ///               The length of buffer1 should equal the length of buffer2.
    /// # Example
    ///
    /// ```
    /// use opl3_rs::Opl3Chip;
    ///
    /// let mut chip = Opl3Chip::new(44100);
    /// let mut buffer1 = [0i16; 1024];
    /// let mut buffer2 = [0i16; 1024];
    /// chip.generate_4ch_stream(&mut buffer1, &mut buffer2);
    /// ```
    pub fn generate_4ch_stream(&mut self, buffer1: &mut [i16], buffer2: &mut [i16]) {
        if buffer1.len() != buffer2.len() {
            panic!("Buffers must be the same length.");
        }
        if buffer1.len() < 4 || buffer2.len() < 4 {
            panic!("Buffers must be at least 4 samples long.");
        }
        unsafe {
            bindings::Opl3Generate4ChStream(
                &mut self.chip,
                buffer1.as_mut_ptr(),
                buffer2.as_mut_ptr(),
                buffer1.len() as u32 / 2,
            );
        }
    }
}

#[cfg(test)]
mod tests {}
